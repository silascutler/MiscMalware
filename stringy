#!/usr/bin/env python3
############################################
# Author: Silas Cutler
# Email: silas@blacklab.io
############################################
#
# Thank you for using this.  I hope it is 
# useful.
#
############################################

import re
import sys
import os.path
import argparse
import requests
import threading
import time

from queue import Queue
from collections import namedtuple

VT_API_KEY = None
t_queue = Queue()


# Find VT API Key from places I may have it
def find_vt_api_key():
	if os.path.isfile( os.path.expanduser("~/.virustotal") ):
		fhandle = open(os.path.expanduser("~/.virustotal"), 'r')
		key = fhandle.read().strip()
		fhandle.close()
		return key

	return None


# First argument is a file.  Using argparse over sys.argv[1] cause why not
def parse_args():
	global VT_API_KEY
	VT_API_KEY = find_vt_api_key()

	parser = argparse.ArgumentParser()
	parser.add_argument("-l", "--limit", help="Threshold for how unique a string should be", default=9000, type=int)
	parser.add_argument("-k", "--vtkey", help="VirusTotal API key if not stored under ~/.virustotal")
	parser.add_argument("file", help="File to parse")
	args = parser.parse_args()

	if VT_API_KEY == None:
		VT_API_KEY = args.vtkey

	if VT_API_KEY == None:
		print("Error: VirusTotal API required")
		parser.print_help()
		sys.exit(1)
	return args



# Dump all unicode and ascii strings.  Based on the code from @williballenthin
def dump_strings(buf, n=8, m=200):
	#ASCII First
	ASCII_BYTE = b" !\"#\$%&\'\(\)\*\+,-\./0123456789:;<=>\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]\^_`abcdefghijklmnopqrstuvwxyz\{\|\}\\\~\t"
	String = namedtuple("String", ["s", "offset", "stype"])


	reg = b"([%s]{%d,%d})" % (ASCII_BYTE, n, m)
	ascii_re = re.compile(reg)
	for match in ascii_re.finditer(buf):
		yield String(match.group().decode("ascii"), match.start(), "ascii")

	# unicode next
	ureg = b"((?:[%s]\x00){%d,%d})" % (ASCII_BYTE, n, m)
	uni_re = re.compile(ureg)
	for match in uni_re.finditer(buf):
		try:
			yield String(match.group().decode("utf-16"), match.start(), "unicode")
		except UnicodeDecodeError:
			pass

def lookup_string(args):
	uArgs, rString = args
	if rString.stype == "ascii":
		sString = bytes(rString.s, "utf-8").hex()
	elif rString.stype == "unicode":
		sString = bytes(rString.s, "utf-16").hex()[4:]

	url = "https://www.virustotal.com/api/v3/intelligence/search?query=content:{%s}&descriptors_only=true&limit=99" % ( sString )
	headers = {'x-apikey': VT_API_KEY}
	try:
		r = requests.get(url, headers=headers, verify=True, timeout=20)
	except Exception as e:
		return False

	if r.status_code != 200:
		return False
	try:
		count = len(r.json()['data'])
		if count < uArgs.limit:
			print("0x%.8x : [%2.d]  [%s] - '%s'" % (rString.offset, count, rString.stype.center(7, " "), rString.s) )
	except Exception as e:
		print(e)
		return False

	return True	


# thread for querying VirusTotal
def lookup_thread():
	while True:
		lookup_req = t_queue.get()
		lookup_string(lookup_req)
		t_queue.task_done()
		time.sleep(0.5)

def main():
	args = parse_args()
	print_lock = threading.Lock()

	try:
		fhandle = open(args.file, 'rb')
		slist = list(set(dump_strings(fhandle.read())))
		fhandle.close()
	except Exception as e:
		print("Exception: %s" % e)
		return ""

	for i in range(0, 5):
		t = threading.Thread(target=lookup_thread)
		t.daemon = True
		t.start()

	print("Checking %d strings..." % len(slist))
	print("OFFSET     : [CNT] [ Type  ] - '<STIRNG>'")
	for x in slist:
		t_queue.put([args, x])

	t_queue.join()


if __name__ == "__main__":
	main()
